## 一、编译阶段

1. diff 算法优化：给每个发生变化的地方添加一个 flag 标记（静态标记），下次发生变化的时候直接找该地方进行对比；只对带有静态标记进行对比；
2. 静态提升：对不参与更新的元素，进行静态提升，只会被创建一次，下次渲染直接复用；
3. 事件监听缓存：默认是不开启状态（false），默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化。开启之后就不带有静态标记，也就不会进行对比；
4. SSR 服务端渲染：当静态内容大到一定量级时候，会用 createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml，就不需要创建对象，然后根据对象渲染

## 二、源码体积

1. 相比于 vue3,vue3 整体体积变小了，移除了一些不常用的 API， 再重要的是 Tree shanking 任何一个函数，如 ref、reavtived、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小

## 三、响应式系统

1. vue2 中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式；vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历
   - 可以监听动态属性的添加
   - 可以监听到数组的索引和数组 length 属性
   - 可以监听删除属性
